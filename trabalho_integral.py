# -*- coding: utf-8 -*-
"""Trabalho integral.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IfopDNUaSeeTmlmQ6TBdtEO0URV7zB_N
"""

import numpy as np

# Define a função que representa o integrando e^(-u)
def funcao_original(u):
    return np.exp(-u)

# Define a função que implementa o método do trapézio adaptativo
def trapezio_adaptativo(func, a, b, epsilon):
    integral_anterior = 0.0  # Inicializa a integral anterior como 0
    erro_anterior = float('inf')  # Inicializa o erro anterior como infinito
    n = 1  # Inicializa o número de subintervalos como 1

    while True:  # Loop para refinamento iterativo da integral
        h = (b - a) / n  # Calcula o tamanho de cada subintervalo (largura)
        x = np.linspace(a, b, n + 1)  # Gera pontos igualmente espaçados no intervalo
        y = func(x)  # Calcula os valores da função nos pontos x
        extremos = (y[0] + y[n]) / 2.0  # Calcula a média dos valores nos extremos dos subintervalos
        integral_atual = extremos * h  # Calcula a contribuição dos extremos para a integral

        for i in range(1, n):  # Loop para somar as contribuições do interior dos subintervalos
            integral_atual += y[i] * h

        erro = abs(integral_atual - integral_anterior) / 3.0  # Calcula o erro estimado

        if erro < epsilon or erro >= erro_anterior:  # Verifica se o erro é aceitável ou se está piorando
            return integral_atual, erro  # Retorna a integral aproximada e o erro estimado

        integral_anterior = integral_atual  # Atualiza a integral anterior
        erro_anterior = erro  # Atualiza o erro anterior
        n *= 2  # Dobra o número de subintervalos para a próxima iteração

# Define o parâmetro de erro desejado
epsilon = 1e-5

# Define um valor para "a"
a = 1.0

# Define um limite superior finito para a integração
limite_superior = 10

# Calcula a integral usando o método do trapézio adaptativo
integral_aproximada, erro_estimado = trapezio_adaptativo(funcao_original, 0, limite_superior, epsilon)

print("Integral Aproximada:", integral_aproximada)
print("Erro Estimado:", erro_estimado)

"""O método do trapézio adaptativo é uma técnica numérica para calcular aproximadamente a integral de uma função em um intervalo específico, usando uma abordagem iterativa. Ele combina a ideia do método do trapézio, que aproxima a área sob uma curva usando trapézios, com um processo de adaptação para melhorar a precisão da integral.

Aqui está um resumo sucinto do método do trapézio adaptativo:

    Divisão Inicial: O intervalo de integração é dividido em um número inicial de subintervalos.

    Cálculo dos Trapézios: A integral é calculada aproximando a área sob a curva em cada subintervalo usando a fórmula do trapézio.

    Erro Estimado: Um erro estimado é calculado comparando as aproximações da integral usando diferentes números de subintervalos. Quanto maior o número de subintervalos, mais precisa é a aproximação.

    Verificação de Precisão: O erro estimado é comparado a um limite de erro predefinido. Se o erro for menor que o limite desejado, a aproximação é aceita como suficientemente precisa.

    Refinamento Adaptativo: Se o erro estimado for maior que o limite desejado, o intervalo é dividido pela metade e a integral é recalculada usando os novos subintervalos. O processo é repetido até que o erro seja aceitável.

O método adapta a quantidade de divisões no intervalo com base no erro estimado, focando mais nos subintervalos onde a função varia mais rapidamente. Isso resulta em uma convergência mais rápida e eficiente para uma aproximação precisa da integral.

No código que você forneceu anteriormente, a função trapezio_adaptativo implementa essa lógica, aumentando o número de subintervalos de maneira iterativa até que o erro estimado atinja o limite desejado.
"""