# -*- coding: utf-8 -*-
"""Exercicios 2 integral .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QsXZiuL4ryI6Wb9e51SUWbDAngHJa9CA
"""

def integral_simpson(func, a, b, N):
    """
    Calcula uma integral usando o método de Simpson.

    Args:
    func: A função a ser integrada.
    a: O limite inferior do intervalo de integração.
    b: O limite superior do intervalo de integração.
    N: O número de segmentos (deve ser um número par) para a aproximação.

    Returns:
    O valor da integral aproximada.
    """
    if N % 2 != 0:
        raise ValueError("O número de segmentos (N) deve ser par.")

    h = (b - a) / N
    soma = func(a) + func(b)

    for i in range(1, N, 2):
        x = a + i * h
        soma += 4 * func(x)

    for i in range(2, N-1, 2):
        x = a + i * h
        soma += 2 * func(x)

    integral_aproximada = (h / 3) * soma
    return integral_aproximada

# Função que queremos integrar
def f(x):
    return x**5 + 3*x + 5

# Definir limites de integração
a = 0
b = 1

# Valores de N para teste
Ns = [10, 100, 1000]

for N in Ns:
    integral_aprox_simpson = integral_simpson(f, a, b, N)
    print(f"N = {N}")
    print("Integral Aproximada (Simpson):", integral_aprox_simpson)

import numpy as np
def simpson(func,a,b,N):
  if (N%2==0):
    print('N é par! Ok!')
    h = (b-a)/N
    #print(h)
    x = np.linspace(a,b,N+1)
    print(x)
    f = func(x)
    #print(f)
    Soma_impares = np.sum(f[1:N+2:2])
    Soma_pares = np.sum(f[0:N:2])
    Extremos = (f[0]+f[N])*h/3.0
    Integral = (4.0/3.0)*h* Soma_impares + (2.0/3.0)*h*Soma_pares
    Integral = Integral + Extremos
  return Integral

def poli(x):
  return x**5+3*x+5


integral = simpson(poli,a=0,b=1,N=10)

print(integral)